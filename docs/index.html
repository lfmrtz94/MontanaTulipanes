
<html><head>
<TITLE>Monta√±a Tulipanes</TITLE>
<script src="CanvasMatrix.js" type="text/javascript"></script>
<script src="Controls.js" type="text/javascript"></script>
<script src="lathe2.js" type="text/javascript"></script>

<script id="shader-vs-gr" type="x-shader/x-vertex">
  attribute vec4 aPos;
  uniform mat4 mvMatrix;
  attribute float disp;
  varying vec2 vTC;
void main(void) {
   vTC = vec2(aPos.x, aPos.z);
   gl_Position = mvMatrix * vec4(aPos.x, aPos.y + disp, aPos.z, 1.);
}
</script> 
<script id="shader-fs-gr" type="x-shader/x-fragment">
precision mediump float;
  varying vec2 vTC;
  uniform sampler2D uTS;
void main(void){
   gl_FragColor = texture2D(uTS, vTC);
}
</script> 

<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec4 aPos;
  attribute vec2 aTC;
  uniform mat4 mvMatrix;
  varying float br;
  varying vec2 vTC;
void main(void) {
   vTC = aTC;
   br = aPos.w;
   gl_Position = mvMatrix * vec4(aPos.xyz, 1.);
}
</script> 
 
<script id="shader-fs" type="x-shader/x-fragment">
precision mediump float;
  varying vec2 vTC;
  varying float br;
  uniform sampler2D uTS;
void main(void){
   vec4 t = texture2D(uTS, vTC);
   gl_FragColor = vec4(br*t.rgb, t.a);
//   gl_FragColor = vec4(vec3(br), 1.);
}
</script> 
 
<script type="text/javascript">

"use strict";

var sm = 15, sn = 9, base, amb = 1, Ro, xR = -55, yR = 0, diGr, diFl, Top = 0,  isMouseDown
var dt, ind, off, di, pi = []
var prMatrix, mvMatrix, mvMatLocFl, mvMatLocGr, tsLocFl, rotMat, c_w, c_h, fi = 0, li = 1,
  proFl, proGr, ext, img,  rnd = Math.random, lines = 0
const stex = 64, tex_st = .0625, np = 50
const tSep = 2, tRed = 3, tYellow = 4, tViolet = 5,
  tFire = 6, tRedW = 7, tRedY = 8, tVioletW = 9, tPink = 10,
  tVioletSr = 11, tRedS = 12, tVioletS = 13, tYellowS = 14, tBlueSr = 15

function webGLStart() {
   document.addEventListener('mouseup', function(){isMouseDown = false}, false)
   initGL()
   let msg = "Your browser does not support "
   ext = gl.getExtension("OES_element_index_uint")
   if(!ext){alert(msg + "OES_element_index_uint extension");return;}
   ext = gl.getExtension("ANGLE_instanced_arrays")
   if ( !ext ) {alert(msg + "ANGLE_instanced_arrays"); return}

   let posLoc = 0,  tcLoc = 1, dispLoc = 2

   let pti = new Float32Array(30)
   for (var i = 0; i < 30; i++)  pti[i] = .01*i + .001
   gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
   gl.bufferData(gl.ARRAY_BUFFER, pti, gl.STATIC_DRAW)
   gl.vertexAttribPointer(dispLoc, 1, gl.FLOAT, false, 0, 0)
   gl.enableVertexAttribArray( dispLoc )
   ext.vertexAttribDivisorANGLE(dispLoc, 1)

   gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
   gl.vertexAttribPointer(posLoc, 4, gl.FLOAT, false, 24, 0)
   gl.enableVertexAttribArray( posLoc )
   gl.vertexAttribPointer(tcLoc, 2, gl.FLOAT, false, 24, 16)
   gl.enableVertexAttribArray( tcLoc )

   gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer())

   img = new Uint8Array(16* stex*stex*4)
   tex(stex)
   let texture = gl.createTexture()
   gl.bindTexture(gl.TEXTURE_2D, texture)
   gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, stex, 16*stex, 0, gl.RGBA, gl.UNSIGNED_BYTE, img)
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST)
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT)
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT)
   gl.generateMipmap(gl.TEXTURE_2D)

   let t = 0, ng = 128, gr = new Uint8Array(ng*ng*4)
   for(let i = 0; i < ng; i++ )  // grass
     for(let j = 0; j < ng; j++ ){
       let c = 150 - 50*rnd()
       if(rnd() < .05){
         gr[t++] = 0;  gr[t++] = c;  gr[t++] = 0;  gr[t++] = 255}
       else{
         gr[t++] = 0;  gr[t++] = c;  gr[t++] = gr[t++] = 0} // ???
   }
   gl.activeTexture(gl.TEXTURE1)
   texture = gl.createTexture()
   gl.bindTexture(gl.TEXTURE_2D, texture)
   gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, ng, ng, 0, gl.RGBA, gl.UNSIGNED_BYTE, gr)
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST)
//   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)

   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT)
//   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT)
   gl.generateMipmap(gl.TEXTURE_2D)

   transl = -120
   c_w = Math.round(.9*window.innerWidth)
   c_h = Math.round(.95*window.innerHeight)
   canvas.width = c_w;   canvas.height = c_h
   gl.viewport(0, 0, c_w, c_h)

   prMatrix = new CanvasMatrix4()
   prMatrix.perspective(70, c_w/c_h, .1, 1000)
   mvMatrix = new CanvasMatrix4()
   rotMat = new CanvasMatrix4()
   rotMat.makeIdentity()
   rotMat.rotate(90, 1,0,0)

   proGr  = gl.createProgram()
   gl.attachShader(proGr, getShader( gl, "shader-vs-gr" ))
   gl.attachShader(proGr, getShader( gl, "shader-fs-gr" ))
   gl.bindAttribLocation(proGr, posLoc, "aPos")
   gl.bindAttribLocation(proGr, dispLoc, "disp")
   gl.linkProgram(proGr)
   gl.useProgram(proGr)
   mvMatLocGr = gl.getUniformLocation(proGr,"mvMatrix")
   gl.uniform1i(gl.getUniformLocation(proGr,"uTS"), 1)

   proFl  = gl.createProgram()
   gl.attachShader(proFl, getShader( gl, "shader-vs" ))
   gl.attachShader(proFl, getShader( gl, "shader-fs" ))
   gl.bindAttribLocation(proFl, posLoc, "aPos")
   gl.bindAttribLocation(proFl, tcLoc, "aTC")
   gl.linkProgram(proFl)
   gl.useProgram(proFl)
   mvMatLocFl = gl.getUniformLocation(proFl,"mvMatrix")
   tsLocFl = gl.getUniformLocation(proFl,"uTS")

   gl.enable(gl.DEPTH_TEST)
   gl.clearColor(.5, .7, 1., 1)
   gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);
   
   dt = new Float32Array(6300000);  ind = new Uint32Array(5000000)
   for (let k = 0; k < 3; k++)  pi[k] = new Float32Array(5*np)
   off = 0;  di = 0
   garden()
//alert(off/6)
   gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, ind, gl.STATIC_DRAW)
   gl.bufferData(gl.ARRAY_BUFFER, dt, gl.STATIC_DRAW)
   drawScene()

  canvas.resize = function (){
   c_w = Math.round(.9*window.innerWidth)
   c_h = Math.round(.95*window.innerHeight)
   canvas.width = c_w;   canvas.height = c_h
    gl.viewport(0, 0, c_w, c_h)
    prMatrix.makeIdentity()
    prMatrix.perspective(70, c_w/c_h, .1, 1000)
    drawScene()
  }
}
function drawScene(){
   gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
   mvMatrix.makeIdentity()
   if(!Top){
     xR += xRot*.1;  yR -= yRot*.3
     mvMatrix.rotate(xR, 0,1,0);  mvMatrix.translate(Ro, -3, 0)
     mvMatrix.rotate(yR, 0,1,0) }
   else{
     rotMat.rotate(xRot, 1,0,0);  rotMat.rotate(yRot, 0,1,0)
     rotMat.rotate(zRot, 0,0,1);  mvMatrix.multRight( rotMat )
     mvMatrix.translate(0, 0, transl) }
   mvMatrix.multRight( prMatrix )
   yRot = xRot = zRot = 0

   gl.useProgram(proFl)
   gl.uniform1i(tsLocFl, 0)
   gl.uniformMatrix4fv( mvMatLocFl, false, new Float32Array(mvMatrix.getAsArray()) )

   if(lines) gl.drawElements(gl.LINES, di, gl.UNSIGNED_INT, 0)
   else gl.drawElements(gl.TRIANGLES, di, gl.UNSIGNED_INT, 0)

   gl.enable(gl.BLEND)
   gl.useProgram(proGr)
   gl.uniformMatrix4fv( mvMatLocGr, false, new Float32Array(mvMatrix.getAsArray()) )
  gl.depthMask(0)
   ext.drawElementsInstancedANGLE(gl.TRIANGLES, diGr - 24, gl.UNSIGNED_INT, 4*24, 15)
   gl.depthMask(1)
   gl.disable(gl.BLEND)

}
function garden(){
   let nd = 12, shZ = 0, y = 0, w = 100, h = 70, ts = tex_st, t2 = 2*ts - .0004,
     b1 = 1., b2 = 1,  Ra = 15
   dt.set([
    -w,0,w,b1, 0,ts, -w,h,w,b1, 0,t2, -w,0,-w,b1, 2,ts, -w,h,-w,b1, 2,t2,
    -w,0,-w,b2, 0,ts, -w,h,-w,b2, 0,t2, w,h,-w,b2, 2,t2, w,0,-w,b2, 2,ts,
    w,0,-w,b1, 0,ts, w,h,-w,b1, 0,t2, w,0,w,b1, 2,ts, w,h,w,b1, 2,t2,
    w,0,w,b2, 0,ts, w,h,w,b1, 0,t2, -w,0,w,b2, 2,ts, -w,h,w,b1, 2,t2
   ])
   ind.set([0,1,2, 2,1,3,  4,5,6, 6,7,4,  8,9,10, 10,9,11,  12,13,14, 14,13,15 ])
   off = 4*24;  di = 4*6
   Ro = 50
   amb = .8
   let t = off/6, nr = 21, nf = 100  // terrain
   for (let i = 0; i < nr; i++){
    let r = Ro + 2*i - 20
    for (let k = 0; k < nf+1; k++){
      let fi = 2*Math.PI*k/nf,
        x = r*Math.sin(fi), z = r*Math.cos(fi),
        h = 4*(1 - Math.cos(.16*(r - Ro)))
      if(r > Ro) h *= .4*(2.5 + Math.cos(8*fi) + Math.sin(6*fi))
      dt[off++] = x;  dt[off++] = h;  dt[off++] = z;  dt[off++] = .6 + .07*h
      dt[off++] = k*.2;  dt[off++] = ts*(2*i/nr - 1) }}
   let tf = t + nf + 1
   for(let i = 0; i < nr-1; i++ ){
     for(let j = 0; j < nf; j++ ){
       ind[di++] = t++;  ind[di++] = t;  ind[di++] = tf
       ind[di++] = tf++; ind[di++] = t;  ind[di++] = tf}
     t++;  tf++}
   diGr = di
   for (let i = 0; i < 9; i++){  // flowers
    let r = Ro + 2 + 2*i
    for (let k = 0; k < 200; k++){
      let f = 2*Math.PI*(k + .5*rnd())/200, ri = r + 1.5*rnd(),
        h = 1.6*(1 - Math.cos(.16*(ri - Ro)))*(2.5 + Math.cos(8*f) + Math.sin(6*f)),
        si = Math.sin(f), co = Math.cos(f),
        x = ri*co, z = ri*si
      fi = 6*rnd();  li = 1.5*(rnd() - .5)
      let o = new Float32Array([co,0,si, 0,1,0, -si,0,co, x,h,z])
      if(i < 3){ sm = 11; sn = 9 }
      else{ sm = 5; sn = 3 }
      let text = 3 + Math.round((12*k)/200)
      if((i < 3)||(h > 5))
       tulip(o, rnd(), -.5*rnd(), .5 + .5*rnd(), text )
   }}
   for (let i = 0; i < 8; i++){  // flowers
    let r = Ro - 3 - 2*i
    for (let k = 0; k < 200; k++){
      let f = 2*Math.PI*(k + .5*rnd())/200, ri = r + 1.5*rnd(),
        h = 4*(1 - Math.cos(.16*(ri - Ro))),
        si = Math.sin(f), co = Math.cos(f),
        x = ri*co, z = ri*si
      fi = 6*rnd();  li = 1.5*(rnd() - .5)
      let o = new Float32Array([co,0,si, 0,1,0, -si,0,co, x,h,z])
      if(i < 3){ sm = 11; sn = 9 }
      else{ sm = 5; sn = 3 }
      let text = 3 + Math.round((12*k)/200)
      if((i < 3)||(h > 5))
       tulip(o, rnd(), .5*rnd(), .5 + .5*rnd(), text )
   }}
}

function tulip(o, age, th, l0, tex){
   let pet = 5
   base = 0
let CP=[ // r, y, fi    leaves
[0.03,0.0,0.64,0.05,0.19,0.36,0.28,0.33,0.76,0.42,0.66,0.00],
[0.03,0.08,0.69,0.06,0.14,0.44,0.50,0.51,0.20,0.4,0.8,0.00],
[0.03,0.05,0.68,0.28,0.03,0.24,0.56,0.29,0.38,0.81,0.12,0.00]]
   for (let k = 0; k < 3; k++)  bezier1DD(CP[k], pi[k])
   for(var i = 1; i >= 0; i-- )   // phi, scr,scy, a, tex_off, amb
     patch(o, li + i*3, 1,1+l0, .3*i, tSep, amb)

   stem(o, .05,.03, l0,.4, th, 5,4, tSep, amb) // a, R0, R, l0, l, th, sr, sf, tex_off
   base = .08
CP=[
[0.05,0.08,0.29,0.36,0.63,0.34,0.01,0.82,0.54,0.00,0.82,0.03],
[0.05,0.08,0.29,0.42,0.25,0.40,0.28,0.88,0.47,0.28,0.89,0.05],
[0.05,0.08,0.34,0.49,0.07,0.34,0.37,0.91,0.57,0.52,0.89,0.06]]
   for (let k = 0; k < 3; k++)  bezier1DD(CP[k], pi[k])
   let dfi = 2*2*Math.PI/5
   for(let i = 1; i <= pet; i++ )    // phi, scr,scy, a, tex_off, amb
     patch(o, dfi*i, .97 + .03*i/pet,1, age*(.98 + .02*i/pet), tex, amb)
}

function clover(o, age){
   sm = 7; sn = 3
   base = 0
let CP=[ // r, y, fi    leaves
[0.03,0.0,0.42,0.03,0.23,0.51,0.29,0.42,0.68,0.46,0.40,0.08],
[0.03,0.0,0.40,0.12,0.31,0.49,0.43,0.35,0.40,0.59,0.31,0.03],
[0.03,0.0,0.37,0.12,0.19,0.44,0.50,0.27,0.38,0.64,0.21,0.07]
]
   for (let k = 0; k < 3; k++)  bezier1DD(CP[k], pi[k])
   for(let i = 1; i <= 3; i++ )   // phi, scr,scy, a, tex_off, amb
     patch(o, 2.1*i + .5*li, 1.3,1.3, 1, tSep, amb)
}

function tex(s){
   let tex = new Uint16Array(4*s*s), t = 0

   for(let i = 0; i < s; i++ )  // ground
     for(let j = 0; j < s; j++ ){
       let c = 200 - 70*rnd()
       img[t++] = 0; img[t++] = c;  img[t++] = 0;  img[t++] = 255
   }

   t = 4*s*s  // mountaine
   for(let i = 0; i < s; i++ )
     for(let j = 0; j < s; j++ ){
       img[t++] = 127
       if(i > j){
         img[t++] = .7*255;  img[t++] = 255 }
       else{
         img[t++] = 220 - 25*rnd() - 3*i;  img[t++] = 0 }
       img[t++] = 255
     }

   t = 0
   for(let i = 0; i < s; i++ ){ // sepals
     let r = s*.9*Math.random()
     for(let j = 0; j < s; j++ ){
         let c = (j > r) ? 150 : 220
         tex[t++] = 0;  tex[t++] = c;  tex[t++] = 0;  tex[t++] = 255
     }
   }
   transp(s, tSep, tex, img)

   t = tRed *4*s*s
   for(let i = 0; i < s; i++ ){
     for(let j = 0; j < s; j++ ){
       img[t++] = Math.min(Math.max(255 - i*5 + 2*j, 80), 255)
       img[t++] = img[t++] = 0;  img[t++] = 255
     }
   }
   t = tPink *4*s*s
   for(let i = 0; i < s; i++ ){
     for(let j = 0; j < s; j++ ){
       img[t++] = 255
       img[t++] = img[t++] = Math.min(Math.max(255 - i*4 + 2*j, 0), 255)
       img[t++] = 255
     }
   }
   t = tYellow *4*s*s
   for(let i = 0; i < s; i++ ){
     for(let j = 0; j < s; j++ ){
       let c = Math.min(Math.max(255 - i*5 + 2*j, 0), 255)
       img[t++] = 255;  img[t++] = c
       img[t++] = 0;  img[t++] = 255
     }
   }
   t = tViolet *4*s*s
   for(let i = 0; i < s; i++ ){
     for(let j = 0; j < s; j++ ){
       let c = Math.min(Math.max(255 - i*5 + 2*j, 0), 255)
       img[t++] = 255;  img[t++] = c
       img[t++] = img[t++] = 255
     }
   }
   t = 0
   for(let i = 0; i < s; i++ ){
     let r = s*(.2 + .5*Math.random())
     let ib = Math.max(30*(i - 45), 0)
     for(let j = 0; j < s; j++ ){
       let wh = ib + Math.max(450 - 22*j, 0)
       let c = (j > r) ? 0 : 255
       tex[t++] = 255;  tex[t++] = Math.min(wh + c, 255)
       tex[t++] = Math.min(wh, 255);  tex[t++] = 255
     }
   }
   transp(s, tFire, tex, img)

   t = tRedW *4*s*s
    for(let i = 0; i < s; i++ ){
     for(let j = 0; j < s; j++ ){
       let wh = Math.min(20*Math.max(j - 35 + .02*Math.random()*i*i, 0), 255)
       img[t++] = Math.min(Math.max(wh + 255 - i*3 + 2*j, 80), 255)
       img[t++] = img[t++] = Math.min(wh, 255)
       img[t++] = 255
     }
    }
   t = tRedY *4*s*s
    for(let i = 0; i < s; i++ ){
     for(let j = 0; j < s; j++ ){
       let wh = Math.min(20*Math.max(j - 35, 0) + .1*Math.random()*i*i, 255)
       img[t++] = Math.min(Math.max(wh + 255 - i*5 + 2*j, 80), 255)
       img[t++] = Math.min(wh, 255);  img[t++] = 0
       img[t++] = 255
     }
    }
   t = tVioletW *4*s*s
    for(let i = 0; i < s; i++ ){
     for(let j = 0; j < s; j++ ){
       let wh = Math.min(20*Math.max(j - 35, 0) + .1*Math.random()*i*i, 255)
       let c = Math.min(Math.max(wh + 205 - i*3 + 2*j, 0), 255)
       img[t++] = c
       img[t++] = wh
       img[t++] = c;   img[t++] = 255
     }
    }

    t = 0
    for(let i = 0; i < s; i++ ){
      let r = s*(.2 + .5*Math.random())
      let ib = Math.max(30*(i - 45), 0)
      for(let j = 0; j < s; j++ ){
        let st = (j > r) ? 0 : 255
        let c = Math.min(ib + 125 + st, 255)
        tex[t++] = c
        tex[t++] = Math.min(ib + st, 255)
        tex[t++] = c;  tex[t++] = 255
      }
    }
    transp(s, tVioletSr, tex, img)
    t = 0
    for(let i = 0; i < s; i++ ){
      let r = s*(.2 + .5*Math.random())
      let ib = Math.max(30*(i - 45), 0)
      for(let j = 0; j < s; j++ ){
        let wh = ib + Math.max(450 - 22*j, 0)
        let c = (j > r) ? 0 : 255
        tex[t++] = Math.min(wh, 255)
        tex[t++] = Math.min(wh + c, 255)
        tex[t++] = tex[t++] = 255
      }
    }
    transp(s, tBlueSr, tex, img)
    t = 0
    for(let i = 0; i < s; i++ ){
     let is = .05*(1 - Math.abs(Math.sin(.12*i))),
      ib = Math.max(25*(i - 45), 0)
     for(let j = 0; j < s; j++ ){
       let wh = is*(s - j)*(s - j) + ib + Math.max(450 - 22*j, 0)
       tex[t++] = Math.min(Math.max(255 - 5*j + 2*i + wh, 80), 255)
       tex[t++] = Math.min(wh, 255)
       tex[t++] = 0;  tex[t++] = 255
     }
    }
    transp(s, tRedS, tex, img)
    t = 0
    for(let i = 0; i < s; i++ ){
     let is = .05*(1 - Math.abs(Math.sin(.12*i))),
      ib = Math.max(25*(i - 45), 0)
     for(let j = 0; j < s; j++ ){
        let wh = is*(s - j)*(s - j) + ib + Math.max(450 - 22*j, 0)
        let c = Math.min(125 + wh, 255)
        tex[t++] = c;  tex[t++] = Math.min(wh, 255)
        tex[t++] = c;  tex[t++] = 255
     }
    }
    transp(s, tVioletS, tex, img)
    t = 0
    for(let i = 0; i < s; i++ ){
     let is = .1*Math.abs(Math.sin(.11*i)),
      ib = Math.max(25*(i - 45), 0)
     for(let j = 0; j < s; j++ ){
       let wh = is*(s - j)*(s - j) + ib
       tex[t++] = 255
       tex[t++] = Math.min(Math.max(255 - 4*j + i + wh, 0), 255)
       tex[t++] = 0;  tex[t++] = 255
     }
    }
    transp(s, tYellowS, tex, img)
}
</script> 
</head>
<body onload="webGLStart();" onresize="canvas.resize();"> 

<canvas id="canvas" width="100" height="100"></canvas> 
<br><input type="checkbox" onclick="Top=checked;drawScene()">Top
<input type="checkbox" onclick="lines=checked;drawScene()">Lines
<br>Use your fingers or mouse to control scene.
Check "Top" for Top view.
<br>WebGL terrain with fixed LOD (check "Lines" to see meshes).
1M vertexes are rendered.

<hr><a href="lathe4.htm">Lathe flowers 2</a>
&nbsp; &nbsp; <i>updated</i> 18 Sep 2017
</body></html>